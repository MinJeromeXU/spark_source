spark-streaming源码分析streaming context，其中streaming context主要包括DStream Graph和JobShceduler,JobScheduler分JobGenerator和ReceiverTracker.



**spark-streaming先介绍整个处理流程:**

    **receiverTracker接收数据的处理：**
streamingContext会启动jobScheduler,jobScheduler会启动receiverTracker调用launchReceiver方法通过自身的消息循环体给自己发送启动receiver的消息。ReceiverTarckerEndpoint内部StartReceiver方法定义了启动receiver的方法(主要是将receiver封装构建一个ReceiverSupervisorImpl，并启动)，这个方法的实现是在executor端执行的，通过sc提交job，job的数据receiverRDD（这个RDD之前做过资源调度就是在那个executor上面创建启动），具体的执行逻辑就是我们封装了receiver的函数。提交job之后再executor启动执行创建一个ReceiverSuppervisorImpl并启动。ReceiverSupersivorImpl主要实现逻辑是启动BlockGenerator和启动startReceiver，然后向ReceiverTarckerEndpoint注册。receiver（数据接收以socketReceiver为例）启动之后就会调用store方法存储接收到的数据，该方法最终会调用blockGenerator的addData方法更新更新buffer数据。（BlockGenerator会每个200ms发起一个定时任务，将buffer中的数据封装成一个block存入阻塞队列中每个block都对应一个StreamBlockId）,Blockgenerator会利用从ReceiverSuppervisorImpl传递进来的监听器将每个block数据存入到BlockManager中。将数据存入到BlockManager会判断是否需要WAL机制产生不同的Blockhandler来处理数据blockhandler(WriteAheadLogBaseBlockHandler和BlockManagerBlockHandler)。存储数据的时候也会根据block数据类型做区分（分别调用不同的api,但是最终都会调用doPuts方法）（buffer,Iterator,bytes）.存入到BlockManager中。BlockManager最终调用doPut方法根据存储级别level做不同的存储（MemeoryStore,DiskStore）
然后向ReceiverTarckerEndpoint发送AddBlock(BlockInfo)消息，receiverTracker的addBlock然后调用receiverBlockTracker将数据做一次WAL然后添加到没有划分的队列中（block还没有划分具体的批次）队列是一个map,一个streamId对应一个流数据（可能有多个流socket,kafka。。。）。

        **Job启动过程：**
数据接收完了但是还没有划分具体的批次，JobScheduler在创建的时候回创建jobGenerator,启动的时候回启动jobGenerator,jobGenerator有一个定时器每个一个durationTime回往自身的消息循环体发送产生该时间批次的job任务，在产生任务之间会划分数据拿到该批次对应的数据。划分逻辑：调用receiverTracker的allocateBlocksToBatch(),先从队列中根据streamId拿到对应流的数据,（streamId，数据）封装成一个AllocatedBlocks。然后判断是否需要做WAL做预写日志。做完之后将原来没有划分队列的数据清空，供下一个批次接受数据。然后再加划分好的数据加入到划分好的队列map（batchtime,数据）中,更新批次时间。
产生job的过程：产生job是根据outputStream产生的，没个输出流产生一个job.输出流调用generateJob方法产生job的时候回调用parent.getOrCompute方法生产RDD,一print这个操作为例:其内部调用print(10)封装了函数逻辑传递给foreachRDD，foreachRdd生产job的时候调用parent.getOrCompute产生BlockRdd，生产blockRdd时候回从BlockManager拿到属于他这个批次的数据，然后调用我们的传递进来的函数逻辑进行输出操作。



**block和batche的关系：**
BlockGenerator内部维护两个线程一个线程每个200ms将currentBuffer中的数据封装成一个block并存入阻塞队列中，另外一个线程不断拿这个队列中的数据存入一个批次当中，这个线程以10s阻塞的方式从阻塞队列拿block数据

后续通过源码分析每一步的过程